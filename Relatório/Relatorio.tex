\documentclass[12pt]{article}
\usepackage{a4wide}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{color}
\usepackage{alltt}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}               
\usepackage{latexsym}
\usepackage{hyperref}
\newenvironment{code}                    
{\textbf{
} \hspace{1cm} \hrulefill \\ 
\smallskip 
\begin{center}
\begin{minipage}{0.9\textwidth} 
\begin{alltt}\small}
{\end{alltt}
\end{minipage}
\end{center}
\hrule\smallskip
}
\renewcommand*\rmdefault{iwona}


% Definição do titulo do documento 
%\begin{

\title{\textsf{Programação Orientada aos Objetos} \\
\begin{tabular}[t]{c}
{\small } \\
{\small Licenciatura em Ciências da Computação | Universidade do Minho} \\
{\small Ano Letivo 2015/2016}  \\
{\small ImOObiliária} \\
{\small (Trabalho prático)} \\
\end{tabular}
}

\author{\small
\\
\\
\begin{tabular}[t]{lll}
 &  \ \ \ \ \ \ \ \  Grupo 18 & \\
62134  & LCC  & Sérgio Oliveira \\
62156  & LCC  & Carlos Silva    \\
\end{tabular}
}

{\begin{document}

\begin{figure*}[b]
        \centering
\includegraphics[scale=0.3]{000.png}	 
\includegraphics[scale=0.2]{001.png}
\end{figure*}


%-------------------- Inicio do Documento ----------------------------------------------------------------------

\maketitle                                            % instrução para incluir o titulo
\pagebreak
                                                        % no documento.

\section{Introdução}
~\\

Somos o grupo 18 da cadeira de Programação Orientada aos Objetos e pertencemos ao curso de Ciências da Computação.
~\\ 

Temos como objetivo construir uma interface (gráfica ou terminal, a escolha é nossa) de gestão de uma imobiliária.
~\\

Este projeto é escrito usando conhecimentos adquiridos nas aulas de Programação Orientada aos Objetos e conhecimentos pessoais.
~\\

A linguagem de programação usada foi a linguagem JAVA, uma das principais linguagens orientadas aos objetos que é conhecida por ser extremamente rica em documentação online, muito dinâmica e fácil de compreender.
~\\


%\begin{figure*}[!b]
     %   \centering
%\includegraphics[scale=0.38]{}
%\end{figure*}
\includegraphics[scale=0.27]{esquema.png}	
\pagebreak

\section{Primeiras classes}
~\\

\textbf{JAVA API}
\newline

Vamos começar com a parte mais obvia de qualquer projeto.\\
Para conseguirmos compilar este programa, recorremos a algumas bibliotecas da Interface de programação de aplicações do JAVA.\\

Essas bibliotecas são as seguintes:
\newline
\begin{code}
java.util;
java.io;
java.lang;
\end{code}

Fizemos grande parte deste projeto no programa BlueJ mas devido a algumas limitações deste programa, começamos a tomar outros rumos.
\newline
\newline
\includegraphics[scale=0.4]{002.png}	 
\newline
\newline

A interface situada na nossa classe principal com a main foi criada em Sublime Text (com a ajuda dos cursores múltiplos) em conjunto com o BlueJ e foi também utilizado ocasionalmente o IntelliJ IDEA.
\newline

Também foi usada a 'Classe que abstrai a utilização da classe Scanner', criada pelo professor F. Mário Martins e uma espécie de Feed de notícias com recurso a uma Queue que foi tirado de um tutorial.
\newline

Sem mais demoras, vamos passar a uma das principais partes do nosso projeto, os imóveis.

\pagebreak

\textbf{\\Imóvel}
\newline

'Imóvel' é a primeira classe que começamos a fazer e é uma das duas classes abstratas do nosso programa, para conseguirmos criar imóveis mais específicos, neste caso, para dividi-los em diversas categorias para determinarmos variáveis extra. 
\newline

A classe é composta pelas variáveis 'estado', 'tipoImóvel', 'morada', 'precoPedido', 'precoMinimo' e 'visitas'. 
\newline

O clone do imóvel é ligeiramente diferente dos clones de classes normais, sendo ele:
\newline
\begin{code}
 abstract Imovel clone();
...
\end{code}
~\\

Também temos dois tipos de toString() diferentes (um para os vendedores e outro para os compradores, que mais tarde falaremos deles), para que possámos ocultar a informação do preço mínimo ao comprador.
\newline
\begin{code}
public String toString()\{
...
\}
\end{code}
~\\

Existe a opção de retornar, gravar e incrementar as visitas aos nossos imóveis para uso na classe 'Consulta', para que quando um utilizador qualquer aceder a um dado imóvel, o sistema consiga registar esse acesso.
\newline

'Imovel' está também povoado pelo típico equals() muito predefinido.
\newline
\begin{code}
...
public boolean equals(Object o)\{
...
\}
...
\end{code}
~\\

Como já está praticamente tudo falado da nossa classe abstrata, iremos então descer na nossa herança para elementos menos abstratos.
\pagebreak

\textbf{'Subclasses de Imóvel'}
\newline
\newline
\includegraphics[scale=0.5]{003.png}	
\newline

Comecemos com a subclasse 'Moradia'. Esta foi a primeira subclasse que fizemos do abstract 'Imovel'. 
Como é habitual nas subclasses, fazemos construtores importando sempre as variáveis importantes da nossa classe abstrata através do método super(), subindo na herança para a nossa superclasse.
\newline

A subclasse 'Apartamento' traz um tipo de variável um pouco habitual nas subclasses que fizemos que é neste caso o 'boolean'. 
Esta subclasse também será importante para outra classe que falaremos daqui a pouco.
\newline

Tanto a classe 'Moradia' como a classe 'Apartamento' têm uma String em comum (Tipo). No entanto, os tipos das duas classes diferem uma da outra. Enquanto que a classe Moradia só aceita como tipos: 'Isolada', 'Germinada', 'Banda' e 'Gaveto'
\newline
\begin{code}

if (!tipo.equals('Isolada')&&!tipo.equals('Germinada')&&
!tipo.equals('Banda')&&!tipo.equals('Gaveto'))
{throw new TipoInvalidoException('Tipo de imóvel inválido');}

\end{code}
~\\

A subclasse Apartamento só aceita estes seguintes tipos: 'Simples', 'Duplex', 'Triplex'
\begin{code}
if (!tipo.equals('Simples')&&!tipo.equals('Duplex')&&!tipo.equals('Triplex'))
{throw new TipoInvalidoException('Tipo de imóvel inválido');}

\end{code}
~\\

Nota: Embora fora das classes, se estas condições não forem aceites, elas irão gerar erros que mais tarde irá ser tratado.
\newline
\newline
\newline

A subclasse Terreno segue o mesmo príncipio das de cima, sendo o nome da String ligeiramente diferente, 'apropriadoPara', tal como a subclasse Loja que tem 'tiponegocio' como nome da String.
\newline

Aqui entra a importância da 'Apartamento', pois uma classe Loja pode ser habitável. Ora, podemos fazer uma subclasse de 'Loja', ficando assim com uma subclasse 'LojaHabitavel', em que o principal objetivo é ligar dados do apartamento a uma dada loja.
\newline
\newline

Todas estas subclasses tem métodos em comum. Para facilitar a vida e para organização de código, foram criadas duas interfaces ('Pesquisa' e 'Habitável' ).
\newline
\newline

A classe 'Pesquisas'  será útil para pesquisar o número de quartos ou o número de WC's de uma dada 'Moradia' ou de um dado 'Apartamento'.
\newline

'Habitável' por outro lado terá utilidade para saber se a loja será habitável ou não e também retornar o preço pedido de um dado 'Imóvel' (sendo 'Terreno' a única exceção, a classe não tem a variável 'preçoPedido' ).    

\pagebreak

\textbf{Utilizadores}
\newline
\newline
\includegraphics[scale=0.2]{006.png}	


Implementámos 3 outras classes para criar um cenário de gestão de utilizadores. 
\newline

Temos uma classe abstrata chamada 'Utilizador' que tem outras duas subclasses ligadas a ela, sendo elas 'Vendedor' e 'Comprador' .
\newline

No projeto 'ImOObiliaria', temos 3 estados que um utilizador pode usar:
\newline
\begin{itemize}
\item Utilizador não registado
\item Vendedor registado
\item Comprador registado
\end{itemize}

O facto de um utilizador estar registado ou não depende de um simples boolean.\\ 

Esse boolean diz-nos se o utilizador em questão já passou pelo estado de registo ou não.
~\\
\newline
\begin{quote}
NOTA: quando construímos um utilizador (vendedor ou comprador) vazio, a flag registado começa sempre com o valor 'false' .
\end{quote}

~\\

Temos dentro da classe 'Utilizadores' um apontador para a principal base de dados 'Imobiliaria' . 
É também uma declaração importante na superclasse que se deixássemos de lado, provavelmente não funcionaria da maneira que queriamos (é de notar que os principais métodos de procura de imóveis estão quase todos nos utilizadores).
\newline

Esse apontador é feito usando:
\newline
\begin{code}
...
    private Imobiliaria imob;
...
\end{code}
que permite então aceder sem problemas aos métodos principais da classe 'Imobiliaria'.
\newline

O resto das variáveis que são usadas na superclasse 'Utilizadores' são bastante normais e constituem o básico para o funcionamento do projeto 'ImOObiliaria'.
\newline

As subclasses tem pouco para mostrar em código, mas são extremamente precisas para que haja uma correta gestão dos dados.
~\\

\textbf{Utilizador não registado}
~\\

Este tipo de utilizador tem acesso à nossa aplicação. No entanto, tem apenas a possibilidade de listar e pesquisar imóveis, fazer o mapeamento dos dados e gerar o top de imóveis visitados.
~\\

\includegraphics[scale=0.5]{007.png}	
\\
\begin{footnotesize}
* Mostramos através da imagem que este utilizador tem acesso restrito na nossa aplicação, podendo contudo para ter um leque maior de opções, acedendo à opção de gerir utilizadores, registando-se e fazendo login.
\end{footnotesize}
\pagebreak

\textbf{Vendedor}
~\\

Um vendedor registado consegue ter permissões avaçandas ao programa, nomeadamente aceder ao menu exclusivo dos vendedores e a algumas opções do menu dos leilões. \\

A classe 'Vendedor' não contém grandes operações. Tem em vez disso dois portfólios distintos (implementados por dois ArrayLists): um para armazenar os imóveis que estão em venda na base de dados e outro para registar os imóveis que já foram vendidos.
\begin{code}
private ArrayList<Imovel> lstImoveisPort;
private ArrayList<Imovel> lstImoveisVendidos;
\end{code}

~\\

O vendedor também tem a possibilidade de remover diretamente um imóvel da base de dados, utilizando para isso o apontador para a classe Imobiliaria.
~\\
\includegraphics[scale=0.5]{008.png}
\\
\begin{footnotesize}
* Menu de vendedor, com todas as opções disponíveis adicionais às de um utilizador não registado
\end{footnotesize}
\pagebreak

\textbf{Comprador}
~\\

Esta classe também tem as suas únicas permissões, mas não tão avançadas como um vendedor. Um comprador pode aceder ao menu exclusivo dos compradores, em que poderá comprar um determinado imóvel. No entanto, a criação, edição ou a eliminação de todos os imóveis não são permitidos.
\\

Um comprador também consegue ter acesso aos leilões, mas dar início a um dado leilão ou encerrar um leilão não são operações permitidas.

O comprador, ao contrário do vendedor, não tem nenhum portfólio de imóveis em venda ou vendidos mas sim uma lista de imóveis da escolha do comprador que possa gostar mais.
\\

A classe 'Comprador' é das únicas classes que recorre à ordenação de listas, recorrendo para isso às classes 'Comparator' que estão situadas no projeto.
~\\
\newline
\begin{code}
... TreeSet <Imovel> (new ImovelStringComparator ()); ...
\end{code}
~\\

Ambas as classes recorrem ao método clone() para no caso de querermos registar informação de um dado utilizador sem alterar absolutamente nada do objeto original.

\includegraphics[scale=0.5]{009.png}
\\
\begin{footnotesize}
* Menu de comprador, também com todas as opções disponíveis adicionais às de um utilizador não registado
\end{footnotesize}
\pagebreak
%-------------------TUDO BEM POR AQUI ----------------------------------------------------------------------

\section{O motor do projeto}

\textbf{Imobiliaria (Base de dados)}
\\

Esta classe é a classe que provavelmente tem o maior número de métodos do nosso projeto (a grande responsável pela criação de dados).
\\

Implementamos esta base de dados com recurso a dois HashMap's, um responsável pelo tratamento dos utilizadores e outro pelos imóveis. 
Como um HashMap tem por predefinição a cada objeto uma referência (chave), decidimos implementar como chave no HashMap utilizadores o email de cada utilizador e a morada de cada imóvel (chave única) no HashMap de imóveis.
~\\
\begin{code}
private HashMap<String,Imovel> imovel;
private HashMap<String,Utilizadores> utilizadores;
\end{code}
~\\

As variáveis de instância desta classe são as que fazem o armazenamento de grande parte dos dados dos imóveis, utilizadores e um feed de notícias . 
\\

Quase todos os 'getters' recorrem a uma lista ou map auxiliares, de forma a que retornemos corretamente os dados enquanto que os 'setters' são práticamente normais.
\\

A classe faz a gestão do inicio e do encerramento da sessão atual, não continuando se a base de dados dos utilizadores não tiver conteúdo ou se nenhuma sessão estiver ativa respetivamente.
\\

Ao iniciarmos um programa, temos que criar um ponto em que haja um tipo de utilizador que não seja abstrato (pois não podemos instanciar uma classe abstrata) nem esteja registado.\\

Para isso recorre-se a uma maneira de simular o que queriamos, criando um método 'init' que inicia um Comprador sem qualquer informação mas que esteja ligado à base de dados, em que a flag 'registado' seja 'false' para não ter permissões aos nossos menus especiais.
\newline
\begin{code}
   public void init()\{atual = new Comprador (',',',',',this,false);\}
\end{code}
~\\

Ao terminar a sessão, a classe cria um ponto de situação em que o utilizador não tem informação e não está registado no sistema (boolean registado = false;).
\newline
\begin{code}
public void fechaSessao()\{... \}
\end{code}
~\\

Os imóveis poderão ser registados, editados, listados ou removidos através desta classe, assim como os utilizadores também poderão ser registados e listados, mas não editados ou removidos.

O algoritmo do mapeamento de imóveis e do top de visitas dos imóveis também foi inserido nesta classe e recorre a apontadores dos dois tipos de utilizadores, para que possámos relacionar as visitas que os compradores ou os vendedores fazem aos imóveis, ou relacionar os vendedores e os seus respetivos imóveis em venda/reservados/vendidos.
~\\

\includegraphics[scale=0.4]{012.png}

\begin{footnotesize}
* Implementado um TreeSet e um HashSet, fazemos a ordenação do Top de imóveis visitados.
\end{footnotesize}

\pagebreak
~\\

Dois dos métodos mais importantes desta classe são os que permitem a função de carregamento ou de salvaguarda de objetos, ou seja, guardar o estado inteiro do nosso programa.
Para isso usa-se então as classes predefinidas de JAVA ObjectInputStream e ObjectOutputStream. 
~\\

\includegraphics[scale=0.4]{010.png}

\pagebreak
\textbf{ImOObiliaria (Main)}
\newline
~\\

Este é o motor de arranque, a classe que tem o controlo dos principais menus de gestão do utilizador, de pesquisa, de vendedor e comprador, do leilão e do mapeamento de imóveis mais o top das consultas de imóveis do programa.

~\\

ImOObiliaria é a grande responsável por listar dados. No entanto, 'insereImovel' é dos únicos métodos nesta função que utiliza o algoritmo de criação de dados em vez de listar, sendo a implementação desta função nesta classe um pouco estranha.
~\\

Nesta classe todas as variáveis estão a static para que não seja possível instanciar as mesmas
variáveis noutras classes, ou seja, só existe uma instância deste campo estático.

Esta classe está dividida em 4 partes:
\newline
\begin{itemize}
\item Janelas;
\item Menus;
\item Métodos de edição de variáveis;
\item Métodos de atualização de avisos.
\end{itemize}

A classe 'ImOObiliaria' terá que ser instanciada no método
InitApp, para que se possa carregar/gerir os objetos.
Para isto, existe a interface Serializable para que o nosso objeto guardado pela classe 'Imobiliaria'
seja sempre compatível com o nosso programa. Ao ser implementado temos que ter em conta
que poderá ocorrer eventos anormais, que caso aconteça, o nosso programa irá usar as Exceptions (que falaremos daqui a bocado)
evitando que se fechará abruptamente gerando um erro. 
~\\

\pagebreak
\section{Outras classes importantes}

\textbf{Leilões}
\newline
~\\

Leilões é a classe que faz a gestão de um leilão. O vendedor tem a oportunidade de meter o seu imóvel em leilão disponível nas horas que o vendedor quiser. O vendedor tem também o poder de encerrar o leilão quando quiser através de uma opção do menu.
~\\

Um comprador pode entrar no leilão e pode escolher entre duas opções:
\begin{itemize}
\item Fazer uma licitação, dando um limite de euros, de X em X minutos; 
\item Fazer uma licitação imediatamente, sem recorrer ao sistema de limite de euros e de tempo.
\end{itemize}
\begin{quote}
NOTA: Independentemente da opção que o comprador escolheu, ele não pode licitar menos que a licitação anterior.
\end{quote}
~\\

Para que esta classe funcione perfeitamente, temos de implementar as seguintes partes da API do JAVA:
\newline
\begin{code}
import java.util.Timer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.Date;
import java.util.TimerTask;
\end{code}
~\\

\textbf{Aposta}
\newline
~\\

Esta classe é usada como suporte à classe Leilões para que consigámos usar um 
\begin{verbatim}
HashMap <String,Aposta>
\end{verbatim}
na parte dos leilões.
Ela é constituída pela identificação do comprador em questão, da informação necessária à licitação e o imóvel que o mesmo quer ganhar.

\textbf{Consulta}
\newline
~\\

Esta classe é muito básica, dando apenas o número de visualizações que cada imóvel da base de dados tem.
Cada consulta começa sem nenhuma visualização como é obvio.
\begin{code}
public Consulta()\{
        this.contagem = 0;
    \}
\end{code}
~\\

\textbf{Feed}
\newline
~\\
\includegraphics[scale=0.5]{011.png}
~\\

\begin{footnotesize}
* Esta classe contém a queue de 10 posições que vai atualizando ao longo das movimentações que fazemos aos dados.
Quando a queue chega aos 10 elementos e queremos adicionar mais um elemento de informação, a queue elimina automaticamente o último elemento que tem.
\end{footnotesize}

\pagebreak

\section{Quando o código rebenta...}

\textbf{Exceptions}
\newline
~\\

Sem contar com a principal classe 'Exception', temos 8 classes que usam a forma de apanhar erros ao longo do código.
\\

O princípio das classes é simples: imprimir as mensagens de erro ou fazer qualquer outra coisa que o programador quiser.
\newline
\begin{code}
public class TipoInvalidoException extends Exception
\{
    TipoInvalidoException(String message)\{
       super(message);
    \}
\}
\end{code}
~\\

Cada operação arriscada é acompanhada com um mecanismo chamado 'try'. Este mecanismo não funciona sem 'catch', que faz com que detete erros no código. Quem 'dispara esse alarme' é o 'throw', que interage com o 'catch', fazendo com que o código pare de executar o código dentro do try, fazendo um 'bypass' a essa secção e executando o código dentro da dada Exception. 
~\\

Quando não ocorre um erro grave no código, o programa executa na mesma o código dentro do try/catch e segue normalmente.  

\pagebreak

%-------------------- ISTO É UM SEPARADOR ... A SÉRIO----------------------------------------------------------------------
 
\section{Conclusão}
~\\

Por fim, encontrámos vários tópicos que não podiamos excluir da nossa conclusão.
~\\
As principais dificuldades que não foram superadas neste projeto foram as seguintes:
\begin{itemize}
\item UTF-8 (utilizaÃ§Ã£o de caract§Ã£res especiais).
\item Leilões (comprador apostar de x em x minutos).
\item Bug de uma variável 'double'  mostrar 0.0 em vez do valor devido.
\item Top X de imóveis não foi inteiramente implementado.
\end{itemize}
~\\
Por outro lado, as dificuldades que foram superadas foram estas:
\begin{itemize}
\item fazer catch de uma exception no lugar errado...
\item Clone() (não dava o apontador do que queriamos)
\item Mapeamento de imóveis dava todos os imóveis para todos os vendedores.
\item Comprar um imóvel não alterava o estado do imóvel para reservado.
\end{itemize}

Não podemos deixar de dizer que este trabalho foi obviamente produtivo e só nos trouxe vantagens para conhecer o mundo dos Exceptions, visto que começamos a percebê-los melhor. A mesma coisa aconteceu com as Interfaces, que eram demasiado 'abstratas' para nós antes deste projeto.

~\\
~\\

\includegraphics[scale=0.4]{005.png}	

\end{document}